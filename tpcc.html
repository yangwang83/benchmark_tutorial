<p>This article is based on the TPC-C specification at http://tpc.org/tpc_documents_current_versions/pdf/tpcc_v5.11.0.pdf.</p>

<p> We provide a brief summary of TPC-C, though a reader is encouraged to read the TPC-C specification first.
TPC-C simulates the database of a wholesale company. It includes
a number of warehouses, each maintaining stocks for 100,000
items and covering 10 districts with 3,000 customers in each. It consists
of nine tables (WAREHOUSE, DISTRICT, CUSTOMER, HISTORY,
ORDER, NEW-ORDER, ORDER-LINE, STOCK, and ITEM)
and five types of transactions:</p>

<ul>

    <li>New-Order: it simulates the procedure of entering an order. It
    randomly selects a district from a warehouse, randomly selects
    5 to 15 items, and randomly selects a quantity of one to ten for
    each item. For each item, it has 1% chance to order from another
    warehouse. This means, with an average of 10 items per order,
    about 9.5% of the orders need to access remote warehouses.
    This transaction retrieves and increments a D_NEXT_O_ID value
    (i.e, the next available order number) from the DISTRICT table,
    uses the value to create an order, and inserts a row in both the
    NEW-ORDER and ORDER table. Then for each item in the order,
    it retrieves the price from the ITEM table and updates the count
    in the STOCK table. Finally it inserts a new row for each item
    in the ORDER-LINE table. There is a 1% chance that the item
    is not found or its count is not sufficient, which will cause this
    transaction to rollback. The D_NEXT_O_ID value is a major
    contention point, since all New-Order transactions of the
    same district needs to update the same D_NEXT_O_ID.</li>


    <li>Payment: it updates the customer’s balance and reflects the payment
    on the district and warehouse sales statistics. It randomly
    selects a district from a warehouse, randomly selects a customer
    from the district, and updates the balance and payment values
    in the corresponding tables. There is a 15% chance that the
    customer’s resident warehouse is a remote warehouse.</li>

    <li>Order-Status: it queries a customer’s last order. It randomly selects
    a district from a warehouse, randomly selects a customer
    from the district, and selects the customer’s order with the largest
    order ID in the ORDER table. Then it selects matching rows from
    the ORDER-LINE table.</li>

    <li>Delivery: given a district, it selects the oldest order from the NEWORDER
    table, deletes this row, retrieves detailed information
    from the ORDER table, and then updates the ORDER-LINE table.
    It finally updates the balance in the CUSTOMER table.</li>

    <li>Stock-Level: it finds the recently sold items that have a stock level
    below a specified threshold. Given a district, it first retrieves the
    D_NEXT_O_ID from the DISTRICT table and then selects order
    lines whose order IDs are greater than or equal to D_NEXT_O_ID
    - 20 from the ORDER-LINE table. For each item in these order
    lines, this transaction checks whether its quantity in the STOCK
    table is less than a threshold.</li>

</ul>

The TPC-C specification further specifies the distribution of
these five types of transactions: New-Order 45%, Payment 43%,
Order-Status 4%, Delivery 4%, and Stock-Level 4%. Because of randomness
in the workload, a small deviation from such distribution
is allowed.

TPC-C adds a wait time, including a keying time and a think
time, before each transaction to simulate the user’s behavior of
typing keyboard and thinking before making a decision. Each
warehouse has ten terminals, one for each district, which means
each warehouse can have at most ten concurrent transactions.
Note that vanilla TPC-C does not allow tuning of these parameters,
except the number of warehouses. However, research prototypes
often tune some of them and we analyze the reasons and
effects of such tuning in this section.

<h3> Stored Procedures vs Interactive Transactions </h3>

A database transaction usually contains multiple SQL statements. There are two
typical ways to store and run a multi-statement transaction: 1) the developer
can predefine the whole transaction, including all its statements,
as a "stored procedure" on the database side. A stored procedure
looks like a function in most programming languages: it can take arguments
from the caller; it can use IF or LOOP statements internally to control
what SQL statements to run and how many iterations to run. A client, which is typically a web application,
can call a stored procedure by giving the name and the arguments of the stored procedure, much
like calling a function; 2) a client can send SQL statements one by one to the database through
a network connection. This approach is often called "interactive transactions", because the client
interacts with the database to determine what to do next. In this approach, the logic (e.g., what
statements to run and how many iterations, etc) is performed at the client side.

The stored procedure mode has an obvious performance benefit: when a transaction
contains multiple statements, a stored procedure needs only two network I/Os, one
from the client to the database server to start the stored procedure and one from
the database server to the client to send the reply; interactive transactions, however,
need two network I/Os for each SQL statement, which incurs a significantly higher network
overhead. Furthermore, for a stored procedure,
since all statements and logic are predefined, it may be possible to statically analyze
its code to find optimization opportunities---this is widely used in research
paper, but such static analysis is much harder, if not impossible, for interactive transactions.

The TPC-C specification does not require to use stored procedures or interactive transactions.
For the performance benefit mentioned above, most industrial companies which submit their scores
for TPC-C use stored procedures; for the static analysis opportunities mentioned above, many research
works use stored procedures as well. However, a study has shown that, in practice, database administrators
are often reluctant to use stored procedures and many real-world applications use interactive transactions or
a mix of stored procedures and interactive transactions.

<h3> Wait time </h3>

<h3> Number of warehouses (i.e., scale factor) </h3>

<h3> Percentage of cross-warehouse transactions </h3>

<h3> Network and disk I/Os </h3>

<h3> Transaction types </h3>

